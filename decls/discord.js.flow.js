/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */
/*eslint-disable */

declare module 'discord.js' {
    declare var version: string;
    declare class Client extends events$EventEmitter {
        constructor(options?: ClientOptions): this;
        browser: boolean;
        channels: Collection<string, Channel>;
        emojis: Collection<string, Emoji>;
        guilds: Collection<string, Guild>;
        options: ClientOptions;
        ping: number;
        pings: number[];
        presences: Collection<string, Presence>;
        readyAt: Date;
        readyTimestamp: number;
        shard: ShardClientUtil;
        status: number;
        token: string;
        uptime: number;
        user: ClientUser;
        users: Collection<string, User>;
        voiceConnections: Collection<string, VoiceConnection>;
        clearInterval(timeout: number): void;
        clearTimeout(timeout: number): void;
        destroy(): Promise<void>;
        fetchApplication(): Promise<ClientOAuth2Application>;
        fetchInvite(code: string): Promise<Invite>;
        fetchUser(id: string): Promise<User>;
        fetchWebhook(id: string, token?: string): Promise<Webhook>;
        generateInvite(permissions: PermissionResolvable[] | number): Promise<string>;
        login(token: string): Promise<string>;
        setInterval(fn: Function, delay: number, ...args: any[]): number;
        setTimeout(fn: Function, delay: number, ...args: any[]): number;
        sweepMessages(lifetime?: number): number;
        syncGuilds(guilds?: Guild[] | Collection<string, Guild>): void;
        on(event: string, listener: Function): this;
        on(event: "channelCreate", listener: (channel: Channel) => void): this;
        on(event: "channelDelete", listener: (channel: Channel) => void): this;
        on(
            event: "channelPinsUpdate",
            listener: (channel: Channel, time: Date) => void): this;
        on(
            event: "channelUpdate",
            listener: (oldChannel: Channel, newChannel: Channel) => void): this;
        on(event: "debug", listener: (info: string) => void): this;
        on(event: "disconnect", listener: () => void): this;
        on(event: "emojiCreate", listener: (emoji: Emoji) => void): this;
        on(event: "emojiCreate", listener: (emoji: Emoji) => void): this;
        on(
            event: "emojiUpdate",
            listener: (oldEmoji: Emoji, newEmoji: Emoji) => void): this;
        on(event: "error", listener: (error: Error) => void): this;
        on(event: "guildBanAdd", listener: (guild: Guild, user: User) => void): this;
        on(event: "guildBanRemove", listener: (guild: Guild, user: User) => void): this;
        on(event: "guildCreate", listener: (guild: Guild) => void): this;
        on(event: "guildDelete", listener: (guild: Guild) => void): this;
        on(event: "guildMemberAdd", listener: (member: GuildMember) => void): this;
        on(event: "guildMemberAvailable", listener: (member: GuildMember) => void): this;
        on(event: "guildMemberRemove", listener: (member: GuildMember) => void): this;
        on(event: "guildMembersChunk", listener: (members: GuildMember[]) => void): this;
        on(
            event: "guildMemberSpeaking",
            listener: (member: GuildMember, speaking: boolean) => void): this;
        on(
            event: "guildMemberUpdate",
            listener: (oldMember: GuildMember, newMember: GuildMember) => void): this;
        on(event: "guildUnavailable", listener: (guild: Guild) => void): this;
        on(
            event: "guildUpdate",
            listener: (oldGuild: Guild, newGuild: Guild) => void): this;
        on(event: "message", listener: (message: Message) => void): this;
        on(event: "messageDelete", listener: (message: Message) => void): this;
        on(
            event: "messageDeleteBulk",
            listener: (messages: Collection<string, Message>) => void): this;
        on(
            event: "messageReactionAdd",
            listener: (messageReaction: MessageReaction, user: User) => void): this;
        on(
            event: "messageReactionRemove",
            listener: (messageReaction: MessageReaction, user: User) => void): this;
        on(event: "messageReactionRemoveAll", listener: (message: Message) => void): this;
        on(
            event: "messageUpdate",
            listener: (oldMessage: Message, newMessage: Message) => void): this;
        on(
            event: "presenceUpdate",
            listener: (oldMember: GuildMember, newMember: GuildMember) => void): this;
        on(event: "ready", listener: () => void): this;
        on(event: "reconnecting", listener: () => void): this;
        on(event: "roleCreate", listener: (role: Role) => void): this;
        on(event: "roleDelete", listener: (role: Role) => void): this;
        on(event: "roleUpdate", listener: (oldRole: Role, newRole: Role) => void): this;
        on(event: "typingStart", listener: (channel: Channel, user: User) => void): this;
        on(event: "typingStop", listener: (channel: Channel, user: User) => void): this;
        on(
            event: "userNoteUpdate",
            listener: (user: UserResolvable, oldNote: string, newNote: string) => void): this;
        on(event: "userUpdate", listener: (oldUser: User, newUser: User) => void): this;
        on(
            event: "voiceStateUpdate",
            listener: (oldMember: GuildMember, newMember: GuildMember) => void): this;
        on(event: "warn", listener: (info: string) => void): this
    }
    declare class Webhook {
        avatar: string;
        channelID: string;
        client: Client;
        guildID: string;
        id: string;
        name: string;
        token: string;
        delete(): Promise<void>;
        edit(name: string, avatar: BufferResolvable): Promise<Webhook>;
        sendCode(
            lang: string,
            content: StringResolvable,
            options?: WebhookMessageOptions): Promise<Message | Message[]>;
        sendFile(
            attachment: BufferResolvable,
            fileName?: string,
            content?: StringResolvable,
            options?: WebhookMessageOptions): Promise<Message>;
        sendMessage(
            content: StringResolvable,
            options?: WebhookMessageOptions): Promise<Message | Message[]>;
        sendSlackMessage(body: Object): Promise<void>;
        sendTTSMessage(
            content: StringResolvable,
            options?: WebhookMessageOptions): Promise<Message | Message[] >
    }
    declare class SecretKey {
        key: Uint8Array
    }
    declare class RequestHandler {
        constructor(restManager: {}): this;
        globalLimit: boolean;
        queue: {}[];
        restManager: {};
        handle(): void;
        push(request: {}): void
    }
    declare class WebhookClient extends Webhook {
        constructor(id: string, token: string, options?: ClientOptions): this;
        options: ClientOptions
    }
    declare class Emoji {
        client: Client;
        createdAt: Date;
        createdTimestamp: number;
        guild: Guild;
        id: string;
        identifier: string;
        managed: boolean;
        name: string;
        requiresColons: boolean;
        roles: Collection<string, Role>;
        url: string;
        equals(other: Emoji | Object): boolean;
        toString(): string
    }
    declare class ReactionEmoji {
        id: string;
        identifier: string;
        name: string;
        reaction: MessageReaction;
        toString(): string
    }
    declare class ClientUser extends User {
        blocked: Collection<string,
        User>;
        email: string;
        friends: Collection<string,
        User>;
        notes: Collection<string,
        string>;
        verified: boolean;
        addFriend(user?: UserResolvable): Promise<User>;
        createGuild(
            name: string,
            region: string,
            icon?: BufferResolvable | Base64Resolvable): Promise<Guild>;
        fetchMentions(
            options?: {
                limit?: number,
                roles?: boolean,
                everyone?: boolean,
                guild?: Guild | string
            }): Promise<Message[]>;
        removeFriend(user?: UserResolvable): Promise<User>;
        setAFK(afk: boolean): Promise<ClientUser>;
        setAvatar(avatar: BufferResolvable | Base64Resolvable): Promise<ClientUser>;
        setEmail(email: string, password: string): Promise<ClientUser>;
        setGame(game: string, streamingURL?: string): Promise<ClientUser>;
        setNote(note: string): Promise<User>;
        setPassword(newPassword: string, oldPassword: string): Promise<ClientUser>;
        setPresence(data: PresenceData): Promise<ClientUser>;
        setStatus(status: PresenceStatus): Promise<ClientUser>;
        setUsername(username: string, password?: string): Promise<ClientUser >
    }
    declare class Presence {
        game: Game;
        status: string;
        equals(other: Presence): boolean
    }
    declare class Channel {
        client: Client;
        createdAt: Date;
        createdTimestamp: number;
        id: string;
        delete(): Promise<Channel >
    }
    declare class DMChannel extends Channel {
		type: "dm";
        lastMessageID: string;
        messages: Collection<string,
        Message>;
        recipient: User;
        typing: boolean;
        typingCount: number;
        awaitMessages(
            filter: CollectorFilterFunction,
            options?: AwaitMessagesOptions): Promise<Collection<string,
        Message >> ;
        bulkDelete(
            messages: Collection<string, Message>| Message[] | number): Promise<Collection<string,
        Message >> ;
        createCollector(filter: CollectorFilterFunction, options?: CollectorOptions): MessageCollector;
        fetchMessage(messageID: string): Promise<Message>;
        fetchMessages(options?: ChannelLogsQueryOptions): Promise<Collection<string,
        Message >> ;
        fetchPinnedMessages(): Promise<Collection<string,
        Message >> ;
        send(content?: StringResolvable, options?: MessageOptions): string;
        sendCode(
            lang: string,
            content: StringResolvable,
            options?: MessageOptions): Promise<Message | Message[]>;
        sendEmbed(embed: RichEmbed, content?: string, options?: MessageOptions): Promise<Message>;
        sendEmbed(embed: RichEmbed, options?: MessageOptions): Promise<Message>;
        sendFile(
            attachment: BufferResolvable,
            fileName?: string,
            content?: StringResolvable,
            options?: MessageOptions): Promise<Message>;
        sendMessage(content: string, options?: MessageOptions): Promise<Message | Message[]>;
        startTyping(count?: number): void;
        stopTyping(force?: boolean): void;
        toString(): string
    }
    declare class GroupDMChannel extends Channel {
		type: "group";
        icon: string;
        lastMessageID: string;
        messages: Collection<string,
        Message>;
        name: string;
        owner: User;
        ownerID: string;
        recipients: Collection<string,
        User>;
        typing: boolean;
        typingCount: number;
        awaitMessages(
            filter: CollectorFilterFunction,
            options?: AwaitMessagesOptions): Promise<Collection<string,
        Message >> ;
        bulkDelete(
            messages: Collection<string, Message>| Message[] | number): Promise<Collection<string,
        Message >> ;
        createCollector(filter: CollectorFilterFunction, options?: CollectorOptions): MessageCollector;
        equals(channel: GroupDMChannel): boolean;
        fetchMessage(messageID: string): Promise<Message>;
        fetchMessages(options?: ChannelLogsQueryOptions): Promise<Collection<string,
        Message >> ;
        fetchPinnedMessages(): Promise<Collection<string,
        Message >> ;
        send(
            content?: StringResolvable,
            options?: MessageOptions): Promise<Message | Message[]>;
        sendCode(
            lang: string,
            content: StringResolvable,
            options?: MessageOptions): Promise<Message | Message[]>;
        sendEmbed(embed: RichEmbed, content?: string, options?: MessageOptions): Promise<Message>;
        sendEmbed(embed: RichEmbed, options?: MessageOptions): Promise<Message>;
        sendFile(
            attachment: BufferResolvable,
            fileName?: string,
            content?: StringResolvable,
            options?: MessageOptions): Promise<Message>;
        sendMessage(content: string, options?: MessageOptions): Promise<Message | Message[]>;
        startTyping(count?: number): void;
        stopTyping(force?: boolean): void;
        toString(): string
    }
    declare class GuildChannel extends Channel {
        guild: Guild;
        name: string;
        permissionOverwrites: Collection<string,
        PermissionOverwrites>;
        position: number;
        clone(name?: string, withPermissions?: boolean): Promise<GuildChannel>;
        createInvite(options?: InviteOptions): Promise<Invite>;
        edit(data: ChannelData): Promise<GuildChannel>;
        equals(channel: GuildChannel): boolean;
        overwritePermissions(
            userOrRole: RoleResolvable | UserResolvable,
            options: PermissionOverwriteOptions): Promise<void>;
        permissionsFor(member: GuildMemberResolvable): EvaluatedPermissions;
        setName(name: string): Promise<GuildChannel>;
        setPosition(position: number): Promise<GuildChannel>;
        setTopic(topic: string): Promise<GuildChannel>;
        toString(): string
    }
    declare class TextChannel extends GuildChannel {
		type: "text";
        lastMessageID: string;
        members: Collection<string,
        GuildMember>;
        messages: Collection<string,
        Message>;
        topic: string;
        typing: boolean;
        typingCount: number;
        awaitMessages(
            filter: CollectorFilterFunction,
            options?: AwaitMessagesOptions): Promise<Collection<string,
        Message >> ;
        bulkDelete(
            messages: Collection<string, Message>| Message[] | number): Promise<Collection<string,
        Message >> ;
        createCollector(filter: CollectorFilterFunction, options?: CollectorOptions): MessageCollector;
        createWebhook(name: string, avatar: BufferResolvable): Promise<Webhook>;
        fetchMessage(messageID: string): Promise<Message>;
        fetchMessages(options?: ChannelLogsQueryOptions): Promise<Collection<string,
        Message >> ;
        fetchPinnedMessages(): Promise<Collection<string,
        Message >> ;
        fetchWebhooks(): Promise<Collection<string,
        Webhook >> ;
        send(
            content?: StringResolvable,
            options?: MessageOptions): Promise<Message | Message[]>;
        sendCode(
            lang: string,
            content: StringResolvable,
            options?: MessageOptions): Promise<Message | Message[]>;
        sendEmbed(embed: RichEmbed, content?: string, options?: MessageOptions): Promise<Message>;
        sendEmbed(embed: RichEmbed, options?: MessageOptions): Promise<Message>;
        sendFile(
            attachment: BufferResolvable,
            fileName?: string,
            content?: StringResolvable,
            options?: MessageOptions): Promise<Message>;
        sendMessage(content: string, options?: MessageOptions): Promise<Message | Message[]>;
        startTyping(count?: number): void;
        stopTyping(force?: boolean): void
    }
    declare class MessageCollector extends events$EventEmitter {
        constructor(channel: Channel, filter: CollectorFilterFunction, options?: CollectorOptions): this;
        channel: Channel;
        collected: Collection<string, Message>;
        filter: CollectorFilterFunction;
        next: Promise<Message>;
        options: CollectorOptions;
        stop(reason?: string): void;
        on(event: "end", listener: (collection: Collection<string, Message>, reason: string) => void): this;
        on(event: "message", listener: (message: Message, collector: MessageCollector) => void): this;
        on(event: string, listener: Function): this;
    }
    declare class Game {
        name: string;
        streaming: boolean;
        type: number;
        url: string;
        equals(other: Game): boolean
    }
    declare class PermissionOverwrites {
        channel: GuildChannel;
        id: string;
        type: string;
        delete(): Promise<PermissionOverwrites >
    }
    declare class Guild {
        afkChannelID: string;
        afkTimeout: number;
        applicationID: string;
        available: boolean;
        channels: Collection<string, GuildChannel>;
        client: Client;
        createdAt: Date;
        createdTimestamp: number;
        defaultChannel: GuildChannel;
        embedEnabled: boolean;
        emojis: Collection<string, Emoji>;
        features: Object[];
        icon: string;
        iconURL: string;
        id: string;
        joinedAt: Date;
        joinedTimestamp: number;
        large: boolean;
        memberCount: number;
        members: Collection<string, GuildMember>;
        name: string;
        owner: GuildMember;
        ownerID: string;
        presences: Collection<string, Presence>;
        region: string;
        roles: Collection<string, Role>;
        splash: string;
        splashURL: string;
        verificationLevel: number;
        voiceConnection: VoiceConnection;
        ban(user: GuildMember, deleteDays?: number): Promise<GuildMember | User | string>;
        createChannel(
            name: string,
            type: "text" | "voice",
            overwrites?: PermissionOverwrites[]): Promise<TextChannel | VoiceChannel>;
        createEmoji(attachment: BufferResolvable, name: string): Promise<Emoji>;
        createRole(data?: RoleData): Promise<Role>;
        delete(): Promise<Guild>;
        deleteEmoji(emoji: Emoji | string): Promise<void>;
        edit(data: GuildEditData): Promise<Guild>;
        equals(guild: Guild): boolean;
        fetchBans(): Promise<Collection<string, User >> ;
        fetchInvites(): Promise<Collection<string, Invite >> ;
        fetchMember(user: UserResolvable): Promise<GuildMember>;
        fetchMembers(query?: string): Promise<Guild>;
        fetchWebhooks(): Collection<string, Webhook>;
        leave(): Promise<Guild>;
        member(user: UserResolvable): ?GuildMember;
        pruneMembers(days: number, dry?: boolean): Promise<number>;
        setAFKChannel(afkChannel: ChannelResovalble): Promise<Guild>;
        setAFKTimeout(afkTimeout: number): Promise<Guild>;
        setIcon(icon: Base64Resolvable): Promise<Guild>;
        setName(name: string): Promise<Guild>;
        setOwner(owner: GuildMemberResolvable): Promise<Guild>;
        setRegion(region: string): Promise<Guild>;
        setRolePosition(role: string | Role, position: number): Promise<Guild>;
        setSplash(splash: Base64Resolvable): Promise<Guild>;
        setVerificationLevel(level: number): Promise<Guild>;
        sync(): void;
        toString(): string;
        unban(user: UserResolvable): Promise<User >
    }
    declare class GuildMember {
        bannable: boolean;
        client: Client;
        deaf: boolean;
        displayName: string;
        guild: Guild;
        highestRole: Role;
        id: string;
        joinedAt: Date;
        joinedTimestamp: number;
        kickable: boolean;
        lastMessageID: string;
        mute: boolean;
        nickname: string;
        permissions: EvaluatedPermissions;
        presence: Presence;
        roles: Collection<string, Role>;
        selfDeaf: boolean;
        selfMute: boolean;
        serverDeaf: boolean;
        serverMute: boolean;
        speaking: boolean;
        user: User;
        voiceChannel: VoiceChannel;
        voiceChannelID: string;
        voiceSessionID: string;
        addRole(role: Role | string): Promise<GuildMember>;
        addRoles(roles: Collection<string, Role>| Role[] | string[]): Promise<GuildMember>;
        ban(deleteDays?: number): Promise<GuildMember>;
        deleteDM(): Promise<DMChannel>;
        edit(data: {}): Promise<GuildMember>;
        hasPermission(permission: PermissionResolvable, explicit?: boolean): boolean;
        hasPermissions(permission: PermissionResolvable[], explicit?: boolean): boolean;
        kick(): Promise<GuildMember>;
        missingPermissions(
            permissions: PermissionResolvable[],
            explicit?: boolean): PermissionResolvable[];
        permissionsIn(channel: ChannelResovalble): EvaluatedPermissions;
        removeRole(role: Role | string): Promise<GuildMember>;
        removeRoles(roles: Collection<string, Role>| Role[] | string[]): Promise<GuildMember>;
        send(
            content?: StringResolvable,
            options?: MessageOptions): Promise<Message | Message[]>;
        sendCode(
            lang: string,
            content: StringResolvable,
            options?: MessageOptions): Promise<Message | Message[]>;
        sendEmbed(embed: RichEmbed, content?: string, options?: MessageOptions): Promise<Message>;
        sendEmbed(embed: RichEmbed, options?: MessageOptions): Promise<Message>;
        sendFile(
            attachment: BufferResolvable,
            fileName?: string,
            content?: StringResolvable,
            options?: MessageOptions): Promise<Message>;
        sendMessage(content: string, options?: MessageOptions): Promise<Message | Message[]>;
        setDeaf(deaf: boolean): Promise<GuildMember>;
        setMute(mute: boolean): Promise<GuildMember>;
        setNickname(nickname: string): Promise<GuildMember>;
        setRoles(roles: Collection<string, Role>| Role[] | string[]): Promise<GuildMember>;
        setVoiceChannel(voiceChannel: ChannelResovalble): Promise<GuildMember>;
        toString(): string
    }
    declare class User {
        avatar: string;
        avatarURL: string;
        bot: boolean;
        client: Client;
        createdAt: Date;
        createdTimestamp: number;
        defaultAvatarURL: string;
        discriminator: string;
        displayAvatarURL: string;
        dmChannel: DMChannel;
        id: string;
        lastMessageID: string;
        note: string;
        presence: Presence;
        username: string;
        addFriend(): Promise<User>;
        block(): Promise<User>;
        deleteDM(): Promise<DMChannel>;
        equals(user: User): boolean;
        fetchProfile(): Promise<UserProfile>;
        removeFriend(): Promise<User>;
        send(
            content?: StringResolvable,
            options?: MessageOptions): Promise<Message | Message[]>;
        sendCode(
            lang: string,
            content: StringResolvable,
            options?: MessageOptions): Promise<Message | Message[]>;
        sendEmbed(embed: RichEmbed, content?: string, options?: MessageOptions): Promise<Message>;
        sendEmbed(embed: RichEmbed, options?: MessageOptions): Promise<Message>;
        sendFile(
            attachment: BufferResolvable,
            fileName?: string,
            content?: StringResolvable,
            options?: MessageOptions): Promise<Message>;
        sendMessage(content: string, options?: MessageOptions): Promise<Message | Message[]>;
        setNote(note: string): Promise<User>;
        toString(): string;
        typingDurationIn(channel: ChannelResovalble): number;
        typingIn(channel: ChannelResovalble): boolean;
        typingSinceIn(channel: ChannelResovalble): Date;
        unblock(): Promise<User >
    }
    declare class PartialGuildChannel {
        client: Client;
        id: string;
        name: string;
        type: string
    }
    declare class PartialGuild {
        client: Client;
        icon: string;
        id: string;
        name: string;
        splash: string
    }
    declare class PendingVoiceConnection {
        channel: VoiceChannel;
        data: Object;
        deathTimer: number;
        voiceManager: ClientVoiceManager;
        setSessionID(sessionID: string): void;
        setTokenAndEndpoint(token: string, endpoint: string): void;
        upgrade(): VoiceConnection
    }
    declare class OAuth2Application {
        client: Client;
        createdAt: Date;
        createdTimestamp: number;
        description: string;
        icon: string;
        iconURL: string;
        id: string;
        name: string;
        rpcOrigins: string[];
        toString(): string
    }
    declare class ClientOAuth2Application extends OAuth2Application {
        flags: number;
        owner: User
    }
    declare class Message {
        attachments: Collection<string, MessageAttachment>;
        author: User;
        channel: TextChannel | DMChannel | GroupDMChannel;
        cleanContent: string;
        client: Client;
        content: string;
        createdAt: Date;
        createdTimestamp: number;
        deletable: boolean;
        editable: boolean;
        editedAt: Date;
        editedTimestamp: number;
        edits: Message[];
        embeds: MessageEmbed[];
        guild: Guild;
        id: string;
        member: GuildMember;
        mentions: {
            users: Collection<string,
            User>,
            roles: Collection<string,
            Role>,
            channels: Collection<string,
            GuildChannel>,
            everyone: boolean
        };
        nonce: string;
        pinnable: boolean;
        pinned: boolean;
        reactions: Collection<string, MessageReaction>;
        system: boolean;
        tts: boolean;
        type: string;
        webhookID: string;
        clearReactions(): Promise<Message>;
        delete(timeout?: number): Promise<Message>;
        edit(content: StringResolvable, options?: MessageEditOptions): Promise<Message>;
        editCode(lang: string, content: StringResolvable): Promise<Message>;
        equals(message: Message, rawData: Object): boolean;
        fetchWebhook(): Promise<Webhook>;
        isMemberMentioned(member: GuildMember | User): boolean;
        isMentioned(data: GuildChannel | User | Role | string): boolean;
        pin(): Promise<Message>;
        react(emoji: string | Emoji | ReactionEmoji): Promise<MessageReaction>;
        reply(
            content: StringResolvable,
            options?: MessageOptions): Promise<Message | Message[]>;
        toString(): string;
        unpin(): Promise<Message >
    }
    declare class MessageEmbed {
        author: MessageEmbedAuthor;
        client: Client;
        color: number;
        createdAt: Date;
        createdTimestamp: number;
        description: string;
        fields: MessageEmbedField[];
        footer: MessageEmbedFooter;
        hexColor: string;
        message: Message;
        provider: MessageEmbedProvider;
        thumbnail: MessageEmbedThumbnail;
        title: string;
        type: string;
        url: string
    }
    declare class MessageEmbedAuthor {
        embed: MessageEmbed;
        iconURL: string;
        name: string;
        url: string
    }
    declare class MessageEmbedField {
        embed: MessageEmbed;
        inline: boolean;
        name: string;
        value: string
    }
    declare class MessageEmbedFooter {
        embed: MessageEmbed;
        iconURL: string;
        proxyIconURL: string;
        text: string
    }
    declare class MessageEmbedProvider {
        embed: MessageEmbed;
        name: string;
        url: string
    }
    declare class MessageEmbedThumbnail {
        embed: MessageEmbed;
        height: number;
        proxyURL: string;
        url: string;
        width: number
    }
    declare class RichEmbed {
        constructor(data?: RichEmbedOptions): this;
        author: {
            name: string,
            url?: string,
            icon_url?: string
        };
        color: number | string;
        description: string;
        fields: {
            name: string,
            value: string,
            inline?: boolean
        }[];
        footer: {
            text?: string,
            icon_url?: string
        };
        image: {
            url: string,
            proxy_url?: string,
            height?: number,
            width?: number
        };
        thumbnail: {
            url: string,
            height?: number,
            width?: number
        };
        timestamp: Date;
        title: string;
        url: string;
        addField(name: string, value: StringResolvable, inline?: boolean): this;
        setAuthor(name: string, icon?: string, url?: string): this;
        setColor(color: string | number | number[]): this;
        setDescription(description: string): this;
        setFooter(text: string, icon?: string): this;
        setImage(url: string): this;
        setThumbnail(url: string): this;
        setTimestamp(timestamp?: Date): this;
        setTitle(title: string): this;
        setURL(url: string): this
    }
    declare class MessageAttachment {
        client: Client;
        filename: string;
        filesize: number;
        height: number;
        id: string;
        message: Message;
        proxyURL: string;
        url: string;
        width: number
    }
    declare class MessageReaction {
        count: number;
        emoji: Emoji | ReactionEmoji;
        me: boolean;
        message: Message;
        users: Collection<string, User>;
        fetchUsers(limit?: number): Promise<Collection<string, User >> ;
        remove(user?: UserResolvable): Promise<MessageReaction >
    }
    declare class Invite {
        channel: GuildChannel | PartialGuildChannel;
        client: Client;
        code: string;
        createdAt: Date;
        createdTimestamp: number;
        expiresAt: Date;
        expiresTimestamp: number;
        guild: Guild | PartialGuild;
        inviter: User;
        maxAge: number;
        maxUses: number;
        temporary: boolean;
        url: string;
        uses: number;
        delete(): Promise<Invite>;
        toString(): string
    }
    declare class VoiceChannel extends GuildChannel {
		type: "dm";
        bitrate: number;
        connection: VoiceConnection;
        joinable: boolean;
        members: Collection<string,
        GuildMember>;
        speakable: boolean;
        userLimit: number;
        join(): Promise<VoiceConnection>;
        leave(): void;
        setBitrate(bitrate: number): Promise<VoiceChannel>;
        setUserLimit(userLimit: number): Promise<VoiceChannel >
    }
    declare class Shard {
        constructor(manager: ShardingManager, id: number, args?: string[]): this;
        env: Object;
        id: string;
        manager: ShardingManager;
        process: child_process$ChildProcess;
        eval(script: string): Promise<any>;
        fetchClientValue(prop: string): Promise<any>;
        send(message: any): Promise<Shard >
    }
    declare class ShardingManager extends events$EventEmitter {
        constructor(file: string, options?: {
            totalShards?: number,
            respawn?: boolean,
            shardArgs?: string[],
            token?: string
        }): this;
        file: string;
        respawn: boolean;
        shardArgs: string[];
        shards: Collection<number, Shard>;
        token: string;
        totalShards: number;
        broadcast(message: any): Promise<Shard[]>;
        broadcastEval(script: string): Promise<any[]>;
        createShard(id: number): Promise<Shard>;
        fetchClientValues(prop: string): Promise<any[]>;
        spawn(amount?: number, delay?: number): Promise<Collection<number, Shard >> ;
        on(event: "launch", listener: (shard: Shard) => void): this;
        on(event: string, listener: Function): this;
    }
    declare class ShardClientUtil {
        constructor(client: Client): this;
        id: number;
        count: number;
        broadcastEval(script: string): Promise<any[]>;
        fetchClientValues(prop: string): Promise<any[]>;
        send(message: any): Promise<void>;
        singleton(client: Client): ShardClientUtil
    }
    declare class UserConnection {
        id: string;
        integrations: Object[];
        name: string;
        revoked: boolean;
        type: string;
        user: User
    }
    declare class UserProfile {
        client: Client;
        connections: Collection<string, UserConnection>;
        mutualGuilds: Collection<string, Guild>;
        premium: boolean;
        user: User
    }
    declare class StreamDispatcher extends events$EventEmitter {
        passes: number;
        paused: boolean;
        time: number;
        totalStreamTime: number;
        volume: number;
        end(): void;
        pause(): void;
        resume(): void;
        setVolume(volume: number): void;
        setVolumeDecibels(db: number): void;
        setVolumeLogarithmic(value: number): void;
        on(event: "debug", listener: (information: string) => void): this;
        on(event: "end", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "speaking", listener: (value: boolean) => void): this;
        on(event: "start", listener: () => void): this;
        on(event: string, listener: Function): this;
    }
    declare class EvaluatedPermissions {
        member: GuildMember;
        raw: number;
        hasPermission(permission: PermissionResolvable, explicit?: boolean): boolean;
        hasPermissions(permission: PermissionResolvable[], explicit?: boolean): boolean;
        serialize(): Permissions
    }
    declare class Role {
        client: Client;
        color: number;
        createdAt: Date;
        createdTimestamp: number;
        guild: Guild;
        hexColor: string;
        hoist: boolean;
        id: string;
        managed: boolean;
        members: Collection<string, GuildMember>;
        mentionable: boolean;
        name: string;
        permissions: number;
        position: number;
        comparePositions(role1: Role, role2: Role): number;
        comparePositionTo(role: Role): number;
        delete(): Promise<Role>;
        edit(data: RoleData): Promise<Role>;
        equals(role: Role): boolean;
        hasPermission(permission: PermissionResolvable, explicit?: boolean): boolean;
        hasPermissions(permissions: PermissionResolvable[], explicit?: boolean): boolean;
        serialize(): Permissions;
        setColor(color: string | number): Promise<Role>;
        setHoist(hoist: boolean): Promise<Role>;
        setMentionable(mentionable: boolean): Promise<Role>;
        setName(name: string): Promise<Role>;
        setPermissions(permissions: PermissionResolvable[]): Promise<Role>;
        setPosition(position: number): Promise<Role>;
        toString(): string
    }
    declare class ClientVoiceManager {
        client: Client;
        connections: Collection<string, VoiceConnection>;
        pending: Collection<string, VoiceConnection>;
        joinChannel(channel: VoiceChannel): Promise<VoiceConnection>;
        sendVoiceStateUpdate(channel: VoiceChannel, options?: Object): void
    }
    declare class AudioPlayer extends events$EventEmitter {
        dispatcher: StreamDispatcher;
        voiceConnection: VoiceConnection
    }
    declare class VoiceConnection extends events$EventEmitter {
        channel: VoiceChannel;
        player: AudioPlayer;
        receivers: VoiceReceiver[];
        speaking: boolean;
        voiceManager: ClientVoiceManager;
        createReceiver(): VoiceReceiver;
        disconnect(): void;
        playConvertedStream(stream: ReadableStream, options?: StreamOptions): StreamDispatcher;
        playFile(file: string, options?: StreamOptions): StreamDispatcher;
        playStream(stream: ReadableStream, options?: StreamOptions): StreamDispatcher;
        on(event: "debug", listener: (message: string) => void): this;
        on(event: "disconnect", listener: (error: Error) => void): this;
        on(event: "error", listener: (error: Error) => void): this;
        on(event: "ready", listener: () => void): this;
        on(event: "speaking", listener: (user: User, speaking: boolean) => void): this;
        on(event: "warn", listener: (warning: string | Error) => void): this;
        on(event: string, listener: Function): this;
    }
    declare class VoiceReceiver extends events$EventEmitter {
        destroyed: boolean;
        voiceConnection: VoiceConnection;
        createOpusStream(user: UserResolvable): ReadableStream;
        createPCMStream(user: UserResolvable): ReadableStream;
        destroy(): void;
        recreate(): void;
        on(event: "opus", listener: (user: User, buffer: Buffer) => void): this;
        on(event: "pcm", listener: (user: User, buffer: Buffer) => void): this;
        on(event: "warn", listener: (message: string) => void): this;
        on(event: string, listener: Function): this;
    }
    declare class Collection<K, V>mixins Map<K, V>{
        array(): V[];
        concat(...collections: Collection<any, any>[]): Collection<any,
        any>;
        deleteAll(): Promise<V>[];
        every(fn: Function, thisArg?: Object): boolean;
		exists(prop: $Keys<V>, value: any): boolean;
        filter(fn: Function, thisArg?: Object): Collection<K, V>;
        filterArray(fn: Function, thisArg?: Object): V[];
		find(propOrFn: $Keys<V> | Function, value?: any): V;
		findAll(prop: $Keys<V>, value: any): V[];
		findKey(propOrFn: $Keys<V> | Function, value?: any): K;
        first(): V;
        firstKey(): K;
        keyArray(): K[];
        last(): V;
        lastKey(): K;
        map(fn: Function, thisArg?: Object): any[];
        random(): V;
        randomKey(): K;
        reduce(fn: Function, startVal?: any): any;
        some(fn: Function, thisArg?: Object): boolean
    }
    declare type AwaitMessagesOptions = {
        errors?: string[]
    } & CollectorOptions

    declare type Base64String = string;
    declare type Base64Resolvable = Buffer | Base64String;
    declare type BufferResolvable = Buffer | string;
    declare type ChannelData = {
        name?: string,
        position?: number,
        topic?: string,
        bitrate?: number,
        userLimit?: number
    };
    declare type ChannelLogsQueryOptions = {
        limit?: number,
        before?: string,
        after?: string,
        around?: string
    };
    declare type ChannelResovalble = Channel | Guild | Message | string;
    declare type ClientOptions = {
        apiRequestMethod?: string,
        shardId?: number,
        shardCount?: number,
        maxMessageCache?: number,
        messageCacheLifetime?: number,
        messageSweepInterval?: number,
        fetchAllMembers?: boolean,
        disableEveryone?: boolean,
        sync?: boolean,
        restWsBridgeTimeout?: number,
        restTimeOffset?: number,
        disabledEvents?: WSEventType[],
        ws?: WebSocketOptions
    };
    declare type CollectorFilterFunction = (message?: Message, collector?: MessageCollector) => boolean;
    declare interface CollectorOptions {
        time?: number,
            max?: number,
            maxMatches?: number
    }
    declare type EmojiIdentifierResolvable = string | Emoji | ReactionEmoji;
    declare type FileOptions = {
        attachment: BufferResolvable,
        name?: string
    };
    declare type GuildEditData = {
        name?: string,
        region?: string,
        verificationLevel?: number,
        afkChannel?: ChannelResovalble,
        afkTimeout?: number,
        icon?: Base64Resolvable,
        owner?: GuildMemberResolvable,
        splash?: Base64Resolvable
    };
    declare type GuildMemberResolvable = GuildMember | User;
    declare type GuildResolvable = Guild | string;
    declare type InviteOptions = {
        temporary?: boolean,
        maxAge?: number,
        maxUses?: number
    };
    declare type InviteResolvable = string;
    declare type MessageEditOptions = {
        embed: RichEmbedOptions
    };
    declare type MessageOptions = {
        tts?: boolean,
        nonce?: string,
        embed?: RichEmbedOptions,
        disableEveryone?: boolean,
        file?: FileOptions | string,
        code?: string,
        split?: boolean | SplitOptions
    };
    declare type PermissionOverwriteOptions = Permissions;
    declare type PermissionResolvable = PermissionString | PermissionString[] | number[];
    declare interface Permissions {
        CREATE_INSTANT_INVITE?: boolean,
            KICK_MEMBERS?: boolean,
            BAN_MEMBERS?: boolean,
            ADMINISTRATOR?: boolean,
            MANAGE_CHANNELS?: boolean,
            MANAGE_GUILD?: boolean,
            READ_MESSAGES?: boolean,
            SEND_MESSAGES?: boolean,
            SEND_TTS_MESSAGES?: boolean,
            MANAGE_MESSAGES?: boolean,
            EMBED_LINKS?: boolean,
            ATTACH_FILES?: boolean,
            READ_MESSAGE_HISTORY?: boolean,
            MENTION_EVERYONE?: boolean,
            EXTERNAL_EMOJIS?: boolean,
            CONNECT?: boolean,
            SPEAK?: boolean,
            MUTE_MEMBERS?: boolean,
            DEAFEN_MEMBERS?: boolean,
            MOVE_MEMBERS?: boolean,
            USE_VAD?: boolean,
            CHANGE_NICKNAME?: boolean,
            MANAGE_NICKNAMES?: boolean,
            MANAGE_ROLES_OR_PERMISSIONS?: boolean,
            MANAGE_WEBHOOKS?: boolean,
            MANAGE_EMOJIS?: boolean
    }
    declare type PermissionString = "CREATE_INSTANT_INVITE" |
        "KICK_MEMBERS" |
        "BAN_MEMBERS" |
        "ADMINISTRATOR" |
        "MANAGE_CHANNELS" |
        "MANAGE_GUILD" |
        "ADD_REACTIONS" |
        "READ_MESSAGES" |
        "SEND_MESSAGES" |
        "SEND_TTS_MESSAGES" |
        "MANAGE_MESSAGES" |
        "EMBED_LINKS" |
        "ATTACH_FILES" |
        "READ_MESSAGE_HISTORY" |
        "MENTION_EVERYONE" |
        "EXTERNAL_EMOJIS" |
        "CONNECT" |
        "SPEAK" |
        "MUTE_MEMBERS" |
        "DEAFEN_MEMBERS" |
        "MOVE_MEMBERS" |
        "USE_VAD" |
        "CHANGE_NICKNAME" |
        "MANAGE_NICKNAMES" |
        "MANAGE_ROLES_OR_PERMISSIONS" |
        "MANAGE_WEBHOOKS" |
        "MANAGE_EMOJIS";
    declare type PresenceData = {
        status?: PresenceStatus,
        afk?: boolean,
        game?: {
            name?: string,
            url?: string
        }
    };
    declare type PresenceStatus = "online" | "idle" | "invisible" | "dnd";
    declare type RichEmbedOptions = {
        title?: string,
        description?: string,
        url?: string,
        timestamp?: Date,
        color?: number | string,
        fields?: {
            name: string,
            value: string,
            inline?: boolean
        }[],
        author?: {
            name: string,
            url?: string,
            icon_url?: string
        },
        thumbnail?: {
            url: string,
            height?: number,
            width?: number
        },
        image?: {
            url: string,
            proxy_url?: string,
            height?: number,
            width?: number
        },
        video?: {
            url: string,
            height: number,
            width: number
        },
        footer?: {
            text?: string,
            icon_url?: string
        }
    };
    declare type RoleData = {
        name?: string,
        color?: number | string,
        hoist?: boolean,
        position?: number,
        permissions?: PermissionString[],
        mentionable?: boolean
    };
    declare type RoleResolvable = Role | string;
    declare type SplitOptions = {
        maxLength?: number,
        char?: string,
        prepend?: string,
        append?: string
    };
    declare type StreamOptions = {
        seek?: number,
        volume?: number,
        passes?: number
    };
    declare type StringResolvable = any[] | string | any;
    declare type UserResolvable = User |
        string |
        Message |
        Guild |
        GuildMember;
    declare type WebhookMessageOptions = {
        tts?: boolean,
        disableEveryone?: boolean
    };
    declare type WebSocketOptions = {
        large_threshold?: number,
        compress?: boolean
    };
    declare type WSEventType = "READY" |
        "GUILD_SYNC" |
        "GUILD_CREATE" |
        "GUILD_DELETE" |
        "GUILD_UPDATE" |
        "GUILD_MEMBER_ADD" |
        "GUILD_MEMBER_REMOVE" |
        "GUILD_MEMBER_UPDATE" |
        "GUILD_MEMBERS_CHUNK" |
        "GUILD_ROLE_CREATE" |
        "GUILD_ROLE_DELETE" |
        "GUILD_ROLE_UPDATE" |
        "GUILD_BAN_ADD" |
        "GUILD_BAN_REMOVE" |
        "CHANNEL_CREATE" |
        "CHANNEL_DELETE" |
        "CHANNEL_UPDATE" |
        "CHANNEL_PINS_UPDATE" |
        "MESSAGE_CREATE" |
        "MESSAGE_DELETE" |
        "MESSAGE_UPDATE" |
        "MESSAGE_DELETE_BULK" |
        "MESSAGE_REACTION_ADD" |
        "MESSAGE_REACTION_REMOVE" |
        "MESSAGE_REACTION_REMOVE_ALL" |
        "USER_UPDATE" |
        "USER_NOTE_UPDATE" |
        "PRESENCE_UPDATE" |
        "VOICE_STATE_UPDATE" |
        "TYPING_START" |
        "VOICE_SERVER_UPDATE" |
        "RELATIONSHIP_ADD" |
        "RELATIONSHIP_REMOVE";
}

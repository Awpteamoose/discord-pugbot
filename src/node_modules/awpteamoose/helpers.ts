import * as R from "ramda";

export const factory = <T> (thing: { new (...arr: Array<any>): T }) => (...arr: Array<any>) => new thing(...arr); // tslint:disable-line
export const randomIndex = <T> (arr: Array<T>): number => {
	return Math.floor(Math.random() * arr.length);
};
export const pickRandom = <T> (arr: Array<T>): T => arr[randomIndex(arr)];
export const delay = (ms: number) => {
	return new Promise<void>((resolve: () => void, reject: () => void) => {
		setTimeout(resolve, ms);
	});
};
export const shuffle = <T>(arr: Array<T>): Array<T> => {
	for (let i = arr.length - 1; i > 0; i -= 1) {
		const j = Math.floor(Math.random() * (i + 1));
		const temp = arr[i];
		arr[i] = arr[j];
		arr[j] = temp;
	}
	return arr;
};
export const pickFirst = <T>(arr: Array<T>): T => arr.length > 0 ? arr[0] : console.error("PICKING FROM AN EMPTY ARRAY") || arr[0];

declare global {
	type JSONValue = undefined | string | number | boolean | JSONObject | JSONArray;
	interface JSONObject { [key: string]: JSONValue; }
	interface JSONArray extends Array<JSONValue> { } // tslint:disable-line

	interface Console {
		logReturn: <T> (message?: T, ...optionalParams: Array<any>) => T; // tslint:disable-line
	}

	interface Array<T> {
		/*
		const generateBindings = (howMany: number) => {
			let str = "";
			for (let j = 1; j <= howMany; j += 1) {
				const iter = j;
				str += "pipe<T, ";
				for (let i = 0; i <= iter; i += 1) {
					str += `R${i}, `;
				}
				str = str.slice(0, -2) + ">(f0: (x: Array<T>) => R0, ";
				for (let i = 1; i <= iter; i += 1) {
					str += `f${i}: (x: R${i - 1}) => R${i}, `;
				}
				str = str.slice(0, -2) + `): R${iter};\n`;
			}
			return str;
		};
		*/
		// tslint:disable
		pipe<T, R0>(f0: (x: Array<T>) => R0): R0;
		pipe<T, R0, R1>(f0: (x: Array<T>) => R0, f1: (x: R0) => R1): R1;
		pipe<T, R0, R1, R2>(f0: (x: Array<T>) => R0, f1: (x: R0) => R1, f2: (x: R1) => R2): R2;
		pipe<T, R0, R1, R2, R3>(f0: (x: Array<T>) => R0, f1: (x: R0) => R1, f2: (x: R1) => R2, f3: (x: R2) => R3): R3;
		pipe<T, R0, R1, R2, R3, R4>(f0: (x: Array<T>) => R0, f1: (x: R0) => R1, f2: (x: R1) => R2, f3: (x: R2) => R3, f4: (x: R3) => R4): R4;
		pipe<T, R0, R1, R2, R3, R4, R5>(f0: (x: Array<T>) => R0, f1: (x: R0) => R1, f2: (x: R1) => R2, f3: (x: R2) => R3, f4: (x: R3) => R4, f5: (x: R4) => R5): R5;
		pipe<T, R0, R1, R2, R3, R4, R5, R6>(f0: (x: Array<T>) => R0, f1: (x: R0) => R1, f2: (x: R1) => R2, f3: (x: R2) => R3, f4: (x: R3) => R4, f5: (x: R4) => R5, f6: (x: R5) => R6): R6;
		pipe<T, R0, R1, R2, R3, R4, R5, R6, R7>(f0: (x: Array<T>) => R0, f1: (x: R0) => R1, f2: (x: R1) => R2, f3: (x: R2) => R3, f4: (x: R3) => R4, f5: (x: R4) => R5, f6: (x: R5) => R6, f7: (x: R6) => R7): R7;
		pipe<T, R0, R1, R2, R3, R4, R5, R6, R7, R8>(f0: (x: Array<T>) => R0, f1: (x: R0) => R1, f2: (x: R1) => R2, f3: (x: R2) => R3, f4: (x: R3) => R4, f5: (x: R4) => R5, f6: (x: R5) => R6, f7: (x: R6) => R7, f8: (x: R7) => R8): R8;
	}
}
Array.prototype.pipe = function<T>(this: Array<T>, ...fns: Array<any>) { return R.pipe.apply(R, fns)(this); }
console.logReturn = <T>(message?: T, ...optionalParams: Array<any>) => { console.log(message, ...optionalParams); return message; }
// tslint:enable
